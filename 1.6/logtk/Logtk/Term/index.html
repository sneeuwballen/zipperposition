<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Term (logtk.Logtk.Term)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">logtk</a> &#x00BB; <a href="../index.html">Logtk</a> &#x00BB; Term</nav><h1>Module <code>Logtk.Term</code></h1><nav class="toc"><ul><li><a href="#terms">Terms</a><ul><li><a href="#term">Term</a></li><li><a href="#constructors">Constructors</a></li><li><a href="#iters">Iters</a></li><li><a href="#subterms-and-positions">Subterms and Positions</a></li><li><a href="#high-level-operations">High-level operations</a></li><li><a href="#fold">Fold</a></li><li><a href="#some-ac-utils">Some AC-utils</a></li><li><a href="#printing/parsing">Printing/parsing</a></li><li><a href="#formulas">Formulas</a></li><li><a href="#arith">Arith</a></li><li><a href="#tptp">TPTP</a></li></ul></li></ul></nav></header><section><header><h2 id="terms"><a href="#terms" class="anchor"></a>Terms</h2></header><aside><p>Those terms provide a direct presentation of higher-order terms with lambdas in the sense that they make currying possible (as well as applying functions to other terms).</p><p>This is as if terms had an `apply` symbol everywhere, but more lightweight.</p><p>Types and terms are mixed because it makes application much easier (applying to a type and to a term are the same thing). It might also make dependent typing possible some day.</p></aside><section><header><h3 id="term"><a href="#term" class="anchor"></a>Term</h3></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <span class="keyword">private</span> <a href="../InnerTerm/index.html#type-t">InnerTerm.t</a></code></dt><dt class="spec type" id="type-term"><a href="#type-term" class="anchor"></a><code><span class="keyword">type</span> term</code><code> = <a href="index.html#type-t">t</a></code></dt><dt class="spec type" id="type-var"><a href="#type-var" class="anchor"></a><code><span class="keyword">type</span> var</code><code> = <span><a href="../Type/index.html#type-t">Type.t</a> <a href="../HVar/index.html#type-t">HVar.t</a></span></code></dt><dd><p>Variables are typed with <a href="../Type/index.html#type-t"><code>Type.t</code></a></p></dd></dl><dl><dt class="spec type" id="type-view"><a href="#type-view" class="anchor"></a><code><span class="keyword">type</span> view</code><code> = <span class="keyword">private</span> </code><table class="variant"><tr id="type-view.AppBuiltin" class="anchored"><td class="def constructor"><a href="#type-view.AppBuiltin" class="anchor"></a><code>| </code><code><span class="constructor">AppBuiltin</span> <span class="keyword">of</span> <a href="../Builtin/index.html#type-t">Builtin.t</a> * <span><a href="index.html#type-t">t</a> list</span></code></td></tr><tr id="type-view.DB" class="anchored"><td class="def constructor"><a href="#type-view.DB" class="anchor"></a><code>| </code><code><span class="constructor">DB</span> <span class="keyword">of</span> int</code></td><td class="doc"><p>Bound variable (De Bruijn index)</p></td></tr><tr id="type-view.Var" class="anchored"><td class="def constructor"><a href="#type-view.Var" class="anchor"></a><code>| </code><code><span class="constructor">Var</span> <span class="keyword">of</span> <a href="index.html#type-var">var</a></code></td><td class="doc"><p>Term variable</p></td></tr><tr id="type-view.Const" class="anchored"><td class="def constructor"><a href="#type-view.Const" class="anchor"></a><code>| </code><code><span class="constructor">Const</span> <span class="keyword">of</span> <a href="../ID/index.html#type-t">ID.t</a></code></td><td class="doc"><p>Typed constant</p></td></tr><tr id="type-view.App" class="anchored"><td class="def constructor"><a href="#type-view.App" class="anchor"></a><code>| </code><code><span class="constructor">App</span> <span class="keyword">of</span> <a href="index.html#type-t">t</a> * <span><a href="index.html#type-t">t</a> list</span></code></td><td class="doc"><p>Application to a list of terms (cannot be left-nested)</p></td></tr><tr id="type-view.Fun" class="anchored"><td class="def constructor"><a href="#type-view.Fun" class="anchor"></a><code>| </code><code><span class="constructor">Fun</span> <span class="keyword">of</span> <a href="../Type/index.html#type-t">Type.t</a> * <a href="index.html#type-t">t</a></code></td><td class="doc"><p>Lambda abstraction</p></td></tr></table></dt></dl><dl><dt class="spec value" id="val-view"><a href="#val-view" class="anchor"></a><code><span class="keyword">val</span> view : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-view">view</a></code></dt></dl><dl><dt class="spec module" id="module-Classic"><a href="#module-Classic" class="anchor"></a><code><span class="keyword">module</span> <a href="Classic/index.html">Classic</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><dl><dt class="spec value" id="val-subterm"><a href="#val-subterm" class="anchor"></a><code><span class="keyword">val</span> subterm : <span>sub:<a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>checks whether <code>sub</code> is a (non-strict) subterm of <code>t</code></p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Interfaces/index.html#module-type-HASH">Interfaces.HASH</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../Interfaces/module-type-HASH/index.html#type-t">t</a> := <a href="index.html#type-t">t</a></code></span></summary><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Interfaces/index.html#module-type-EQ">Interfaces.EQ</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-hash"><a href="#val-hash" class="anchor"></a><code><span class="keyword">val</span> hash : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Interfaces/index.html#module-type-ORD">Interfaces.ORD</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../Interfaces/module-type-ORD/index.html#type-t">t</a> := <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-ty"><a href="#val-ty" class="anchor"></a><code><span class="keyword">val</span> ty : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Type/index.html#type-t">Type.t</a></code></dt><dd><p>Obtain the type of a term..</p></dd></dl><div class="spec module" id="module-IntMap"><a href="#module-IntMap" class="anchor"></a><code><span class="keyword">module</span> IntMap : Map.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-IntMap">IntMap</a>.key = int</code></div><div class="spec module" id="module-Set"><a href="#module-Set" class="anchor"></a><code><span class="keyword">module</span> Set : CCSet.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-Set">Set</a>.elt = <a href="index.html#type-t">t</a></code></div><div class="spec module" id="module-Map"><a href="#module-Map" class="anchor"></a><code><span class="keyword">module</span> Map : CCMap.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-Map">Map</a>.key = <a href="index.html#type-t">t</a></code></div><div class="spec module" id="module-Tbl"><a href="#module-Tbl" class="anchor"></a><code><span class="keyword">module</span> Tbl : CCHashtbl.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-Tbl">Tbl</a>.key = <a href="index.html#type-t">t</a></code></div><dl><dt class="spec value" id="val-hash_mod_alpha"><a href="#val-hash_mod_alpha" class="anchor"></a><code><span class="keyword">val</span> hash_mod_alpha : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Hash invariant w.r.t variable renaming</p></dd></dl><dl><dt class="spec value" id="val-same_l"><a href="#val-same_l" class="anchor"></a><code><span class="keyword">val</span> same_l : <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>same_l l1 l2</code> returns <code>true</code> if terms of <code>l1</code> and <code>l2</code> are pairwise equal, <code>false</code> otherwise. Precondition: both lists have the same length</p><dl><dt>raises Assert_failure</dt><dd><p>if lists have not the same length</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-same_l_gen"><a href="#val-same_l_gen" class="anchor"></a><code><span class="keyword">val</span> same_l_gen : <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>same_l l1 l2</code> returns <code>true</code> if terms of <code>l1</code> and <code>l2</code> are pairwise equal, <code>false</code> otherwise. Precondition: both lists have the same length</p><dl><dt>raises Assert_failure</dt><dd><p>if lists have not the same length</p></dd></dl></dd></dl></section><section><header><h3 id="constructors"><a href="#constructors" class="anchor"></a>Constructors</h3></header><dl><dt class="spec value" id="val-var"><a href="#val-var" class="anchor"></a><code><span class="keyword">val</span> var : <a href="index.html#type-var">var</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-var_of_int"><a href="#val-var_of_int" class="anchor"></a><code><span class="keyword">val</span> var_of_int : <span>ty:<a href="../Type/index.html#type-t">Type.t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-bvar"><a href="#val-bvar" class="anchor"></a><code><span class="keyword">val</span> bvar : <span>ty:<a href="../Type/index.html#type-t">Type.t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create a bound variable. Providing a type is mandatory. <b>Warning</b>: be careful and try not to use this function directly.</p><dl><dt>raises InnerTerm.IllFormedTerm</dt><dd><p>if the index is &lt; 0</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-builtin"><a href="#val-builtin" class="anchor"></a><code><span class="keyword">val</span> builtin : <span>ty:<a href="../Type/index.html#type-t">Type.t</a></span> <span>&#45;&gt;</span> <a href="../Builtin/index.html#type-t">Builtin.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-app_builtin"><a href="#val-app_builtin" class="anchor"></a><code><span class="keyword">val</span> app_builtin : <span>ty:<a href="../Type/index.html#type-t">Type.t</a></span> <span>&#45;&gt;</span> <a href="../Builtin/index.html#type-t">Builtin.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-const"><a href="#val-const" class="anchor"></a><code><span class="keyword">val</span> const : <span>ty:<a href="../Type/index.html#type-t">Type.t</a></span> <span>&#45;&gt;</span> <a href="../ID/index.html#type-t">ID.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create a typed constant</p></dd></dl><dl><dt class="spec value" id="val-tyapp"><a href="#val-tyapp" class="anchor"></a><code><span class="keyword">val</span> tyapp : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../Type/index.html#type-t">Type.t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Apply a term to types</p><dl><dt>raises Type.Error</dt><dd><p>if types do not match.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-app"><a href="#val-app" class="anchor"></a><code><span class="keyword">val</span> app : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Apply a term to a list of terms</p><dl><dt>raises Type.ApplyError</dt><dd><p>if types do not match.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-app_w_ty"><a href="#val-app_w_ty" class="anchor"></a><code><span class="keyword">val</span> app_w_ty : <span>ty:<a href="../Type/index.html#type-t">Type.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Apply a term to a list of terms</p><dl><dt>raises Type.ApplyError</dt><dd><p>if types do not match.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-app_full"><a href="#val-app_full" class="anchor"></a><code><span class="keyword">val</span> app_full : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../Type/index.html#type-t">Type.t</a> list</span> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Apply the term to types, then to terms</p></dd></dl><dl><dt class="spec value" id="val-true_"><a href="#val-true_" class="anchor"></a><code><span class="keyword">val</span> true_ : <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-false_"><a href="#val-false_" class="anchor"></a><code><span class="keyword">val</span> false_ : <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-fun_"><a href="#val-fun_" class="anchor"></a><code><span class="keyword">val</span> fun_ : <a href="../Type/index.html#type-t">Type.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-fun_l"><a href="#val-fun_l" class="anchor"></a><code><span class="keyword">val</span> fun_l : <span><a href="../Type/index.html#type-t">Type.t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-fun_of_fvars"><a href="#val-fun_of_fvars" class="anchor"></a><code><span class="keyword">val</span> fun_of_fvars : <span><a href="index.html#type-var">var</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Build a function from a list of free vars + the body. This performs the De Bruijn transformation, and shifts the body.</p></dd></dl><dl><dt class="spec value" id="val-open_fun"><a href="#val-open_fun" class="anchor"></a><code><span class="keyword">val</span> open_fun : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../Type/index.html#type-t">Type.t</a> list</span> * <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-open_fun_offset"><a href="#val-open_fun_offset" class="anchor"></a><code><span class="keyword">val</span> open_fun_offset : <span>offset:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-var">var</a> list</span> * <a href="index.html#type-t">t</a> * int</code></dt><dd><p><code>open_fun ~offset (λxy. F)</code> returns <code>[v1,v2], F[v1/x,v2/y], offset+2</code> where <code>v1</code> and <code>v2</code> are fresh variables starting from offset</p></dd></dl><dl><dt class="spec value" id="val-grounding"><a href="#val-grounding" class="anchor"></a><code><span class="keyword">val</span> grounding : <a href="../Type/index.html#type-t">Type.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>grounding ty</code> is a unique constant of type <code>ty</code></p></dd></dl><dl><dt class="spec value" id="val-is_var"><a href="#val-is_var" class="anchor"></a><code><span class="keyword">val</span> is_var : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_appbuiltin"><a href="#val-is_appbuiltin" class="anchor"></a><code><span class="keyword">val</span> is_appbuiltin : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_bvar"><a href="#val-is_bvar" class="anchor"></a><code><span class="keyword">val</span> is_bvar : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_formula"><a href="#val-is_formula" class="anchor"></a><code><span class="keyword">val</span> is_formula : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_app"><a href="#val-is_app" class="anchor"></a><code><span class="keyword">val</span> is_app : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_const"><a href="#val-is_const" class="anchor"></a><code><span class="keyword">val</span> is_const : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_fun"><a href="#val-is_fun" class="anchor"></a><code><span class="keyword">val</span> is_fun : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_app_var"><a href="#val-is_app_var" class="anchor"></a><code><span class="keyword">val</span> is_app_var : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_type"><a href="#val-is_type" class="anchor"></a><code><span class="keyword">val</span> is_type : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Does it have type <code>tType</code>?</p></dd></dl><dl><dt class="spec value" id="val-in_pfho_fragment"><a href="#val-in_pfho_fragment" class="anchor"></a><code><span class="keyword">val</span> in_pfho_fragment : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-in_lfho_fragment"><a href="#val-in_lfho_fragment" class="anchor"></a><code><span class="keyword">val</span> in_lfho_fragment : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_fo_term"><a href="#val-is_fo_term" class="anchor"></a><code><span class="keyword">val</span> is_fo_term : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_true_or_false"><a href="#val-is_true_or_false" class="anchor"></a><code><span class="keyword">val</span> is_true_or_false : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-mk_fresh_skolem"><a href="#val-mk_fresh_skolem" class="anchor"></a><code><span class="keyword">val</span> mk_fresh_skolem : <span><a href="index.html#type-var">var</a> list</span> <span>&#45;&gt;</span> <a href="../Type/index.html#type-t">Type.t</a> <span>&#45;&gt;</span> <span>(<a href="../ID/index.html#type-t">ID.t</a> * <a href="../Type/index.html#type-t">Type.t</a>)</span> * <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-as_const"><a href="#val-as_const" class="anchor"></a><code><span class="keyword">val</span> as_const : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../ID/index.html#type-t">ID.t</a> option</span></code></dt><dt class="spec value" id="val-as_const_exn"><a href="#val-as_const_exn" class="anchor"></a><code><span class="keyword">val</span> as_const_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../ID/index.html#type-t">ID.t</a></code></dt><dt class="spec value" id="val-as_var"><a href="#val-as_var" class="anchor"></a><code><span class="keyword">val</span> as_var : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-var">var</a> option</span></code></dt><dt class="spec value" id="val-as_var_exn"><a href="#val-as_var_exn" class="anchor"></a><code><span class="keyword">val</span> as_var_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-var">var</a></code></dt><dt class="spec value" id="val-as_bvar_exn"><a href="#val-as_bvar_exn" class="anchor"></a><code><span class="keyword">val</span> as_bvar_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-as_app"><a href="#val-as_app" class="anchor"></a><code><span class="keyword">val</span> as_app : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * <span><a href="index.html#type-t">t</a> list</span></code></dt><dd><p><code>as_app t</code> decomposes <code>t</code> into a head (non-application) and arguments, such as <code>(let f,l = as_app t in app f l) = t</code></p></dd></dl><dl><dt class="spec value" id="val-as_fun"><a href="#val-as_fun" class="anchor"></a><code><span class="keyword">val</span> as_fun : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../Type/index.html#type-t">Type.t</a> list</span> * <a href="index.html#type-t">t</a></code></dt><dd><p>Open functions</p></dd></dl><dl><dt class="spec value" id="val-head_term"><a href="#val-head_term" class="anchor"></a><code><span class="keyword">val</span> head_term : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>head_term t = fst (as_app t)</code></p></dd></dl><dl><dt class="spec value" id="val-head_term_mono"><a href="#val-head_term_mono" class="anchor"></a><code><span class="keyword">val</span> head_term_mono : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>head term, but still with type arguments</p></dd></dl><dl><dt class="spec value" id="val-args"><a href="#val-args" class="anchor"></a><code><span class="keyword">val</span> args : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span></code></dt><dd><p><code>args t = snd (as_app t)</code></p></dd></dl><dl><dt class="spec value" id="val-of_term_unsafe"><a href="#val-of_term_unsafe" class="anchor"></a><code><span class="keyword">val</span> of_term_unsafe : <a href="../InnerTerm/index.html#type-t">InnerTerm.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><b>NOTE</b>: this can break the invariants and make <a href="index.html#type-view"><code>view</code></a> fail. Only apply with caution.</p></dd></dl><dl><dt class="spec value" id="val-of_term_unsafe_l"><a href="#val-of_term_unsafe_l" class="anchor"></a><code><span class="keyword">val</span> of_term_unsafe_l : <span><a href="../InnerTerm/index.html#type-t">InnerTerm.t</a> list</span> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span></code></dt><dt class="spec value" id="val-of_ty"><a href="#val-of_ty" class="anchor"></a><code><span class="keyword">val</span> of_ty : <a href="../Type/index.html#type-t">Type.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Upcast from type</p></dd></dl><dl><dt class="spec value" id="val-mk_tmp_cst"><a href="#val-mk_tmp_cst" class="anchor"></a><code><span class="keyword">val</span> mk_tmp_cst : <span>counter:<span>int Pervasives.ref</span></span> <span>&#45;&gt;</span> <span>ty:<a href="../Type/index.html#type-t">Type.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt></dl><div class="spec module" id="module-VarSet"><a href="#module-VarSet" class="anchor"></a><code><span class="keyword">module</span> VarSet : CCSet.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-VarSet">VarSet</a>.elt = <a href="index.html#type-var">var</a></code></div><div class="spec module" id="module-VarMap"><a href="#module-VarMap" class="anchor"></a><code><span class="keyword">module</span> VarMap : CCMap.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-VarMap">VarMap</a>.key = <a href="index.html#type-var">var</a></code></div><div class="spec module" id="module-VarTbl"><a href="#module-VarTbl" class="anchor"></a><code><span class="keyword">module</span> VarTbl : CCHashtbl.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-VarTbl">VarTbl</a>.key = <a href="index.html#type-var">var</a></code></div></section><section><header><h3 id="iters"><a href="#iters" class="anchor"></a>Iters</h3></header><div class="spec module" id="module-Seq"><a href="#module-Seq" class="anchor"></a><code><span class="keyword">module</span> <a href="Seq/index.html">Seq</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-var_occurs"><a href="#val-var_occurs" class="anchor"></a><code><span class="keyword">val</span> var_occurs : <span>var:<a href="index.html#type-var">var</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>var_occurs ~var t</code> true iff <code>var</code> in t</p></dd></dl><dl><dt class="spec value" id="val-is_ground"><a href="#val-is_ground" class="anchor"></a><code><span class="keyword">val</span> is_ground : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>is the term ground? (no free vars)</p></dd></dl><dl><dt class="spec value" id="val-is_linear"><a href="#val-is_linear" class="anchor"></a><code><span class="keyword">val</span> is_linear : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>is the term ground? (no free vars)</p><p>is the term linear? (no vars occuring multiple times)</p></dd></dl><dl><dt class="spec value" id="val-monomorphic"><a href="#val-monomorphic" class="anchor"></a><code><span class="keyword">val</span> monomorphic : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>is the term linear? (no vars occuring multiple times)</p><p>true if the term contains no type var</p></dd></dl><dl><dt class="spec value" id="val-is_beta_reducible"><a href="#val-is_beta_reducible" class="anchor"></a><code><span class="keyword">val</span> is_beta_reducible : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-has_lambda"><a href="#val-has_lambda" class="anchor"></a><code><span class="keyword">val</span> has_lambda : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-max_var"><a href="#val-max_var" class="anchor"></a><code><span class="keyword">val</span> max_var : <a href="index.html#module-VarSet">VarSet</a>.t <span>&#45;&gt;</span> int</code></dt><dd><p>find the maximum variable</p></dd></dl><dl><dt class="spec value" id="val-min_var"><a href="#val-min_var" class="anchor"></a><code><span class="keyword">val</span> min_var : <a href="index.html#module-VarSet">VarSet</a>.t <span>&#45;&gt;</span> int</code></dt><dd><p>minimum variable</p></dd></dl><dl><dt class="spec value" id="val-add_vars"><a href="#val-add_vars" class="anchor"></a><code><span class="keyword">val</span> add_vars : <span>unit <a href="index.html#module-VarTbl">VarTbl</a>.t</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>add variables of the term to the set</p></dd></dl><dl><dt class="spec value" id="val-vars"><a href="#val-vars" class="anchor"></a><code><span class="keyword">val</span> vars : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#module-VarSet">VarSet</a>.t</code></dt><dd><p>compute variables of the terms</p></dd></dl><dl><dt class="spec value" id="val-vars_prefix_order"><a href="#val-vars_prefix_order" class="anchor"></a><code><span class="keyword">val</span> vars_prefix_order : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-var">var</a> list</span></code></dt><dd><p>variables in prefix traversal order</p></dd></dl><dl><dt class="spec value" id="val-depth"><a href="#val-depth" class="anchor"></a><code><span class="keyword">val</span> depth : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>depth of the term</p></dd></dl><dl><dt class="spec value" id="val-head"><a href="#val-head" class="anchor"></a><code><span class="keyword">val</span> head : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../ID/index.html#type-t">ID.t</a> option</span></code></dt><dd><p>head ID.t</p></dd></dl><dl><dt class="spec value" id="val-head_exn"><a href="#val-head_exn" class="anchor"></a><code><span class="keyword">val</span> head_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../ID/index.html#type-t">ID.t</a></code></dt><dd><p>head ID.t (or Invalid_argument)</p></dd></dl><dl><dt class="spec value" id="val-size"><a href="#val-size" class="anchor"></a><code><span class="keyword">val</span> size : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Size (number of nodes)</p></dd></dl><dl><dt class="spec value" id="val-simplify_bools"><a href="#val-simplify_bools" class="anchor"></a><code><span class="keyword">val</span> simplify_bools : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-normalize_bools"><a href="#val-normalize_bools" class="anchor"></a><code><span class="keyword">val</span> normalize_bools : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-cover_with_terms"><a href="#val-cover_with_terms" class="anchor"></a><code><span class="keyword">val</span> cover_with_terms : <span>?&#8288;depth:int</span> <span>&#45;&gt;</span> <span>?&#8288;recurse:bool</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span><a href="index.html#type-t">t</a> option</span> list</span> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span></code></dt><dt class="spec value" id="val-max_cover"><a href="#val-max_cover" class="anchor"></a><code><span class="keyword">val</span> max_cover : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span><a href="index.html#type-t">t</a> option</span> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-weight"><a href="#val-weight" class="anchor"></a><code><span class="keyword">val</span> weight : <span>?&#8288;var:int</span> <span>&#45;&gt;</span> <span>?&#8288;sym:<span>(<a href="../ID/index.html#type-t">ID.t</a> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Compute the weight of a term, given a weight for variables and one for ID.ts.</p><dl><dt>parameter var</dt><dd><p>unique weight for every variable (default 1)</p></dd></dl><dl><dt>parameter sym</dt><dd><p>function from ID.ts to their weight (default <code>const 1</code>)</p></dd></dl><dl><dt>since</dt><dd>0.5.3</dd></dl></dd></dl><dl><dt class="spec value" id="val-ho_weight"><a href="#val-ho_weight" class="anchor"></a><code><span class="keyword">val</span> ho_weight : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-ty_vars"><a href="#val-ty_vars" class="anchor"></a><code><span class="keyword">val</span> ty_vars : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../Logtk__Type/index.html#module-VarSet">Logtk.Type.VarSet</a>.t</code></dt><dd><p>Set of free type variables</p></dd></dl><dl><dt class="spec value" id="val-is_ho_var"><a href="#val-is_ho_var" class="anchor"></a><code><span class="keyword">val</span> is_ho_var : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_ho_app"><a href="#val-is_ho_app" class="anchor"></a><code><span class="keyword">val</span> is_ho_app : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_ho_app (F t1…tn)</code> is true, when <code>F</code> is a variable (of any function type)</p></dd></dl><dl><dt class="spec value" id="val-as_ho_app"><a href="#val-as_ho_app" class="anchor"></a><code><span class="keyword">val</span> as_ho_app : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>(<span><a href="../Type/index.html#type-t">Type.t</a> <a href="../HVar/index.html#type-t">HVar.t</a></span> * <span><a href="index.html#type-t">t</a> list</span>)</span> option</span></code></dt><dd><p><code>as_ho_app (F t1…tn) = Some (F, [t1…tn])</code></p></dd></dl><dl><dt class="spec value" id="val-is_ho_pred"><a href="#val-is_ho_pred" class="anchor"></a><code><span class="keyword">val</span> is_ho_pred : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_ho_pred (F t1…tn)</code> is true, when <code>F</code> is a predicate variable</p></dd></dl><dl><dt class="spec value" id="val-is_ho_at_root"><a href="#val-is_ho_at_root" class="anchor"></a><code><span class="keyword">val</span> is_ho_at_root : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_ho_at_root t</code> returns <code>true</code> if the term <code>t</code> is a higher-order variable, possibly applied (i.e. <code>is_ho_var t || is_ho_app t</code>)</p></dd></dl></section><section><header><h3 id="subterms-and-positions"><a href="#subterms-and-positions" class="anchor"></a>Subterms and Positions</h3></header><div class="spec module" id="module-Pos"><a href="#module-Pos" class="anchor"></a><code><span class="keyword">module</span> <a href="Pos/index.html">Pos</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-replace"><a href="#val-replace" class="anchor"></a><code><span class="keyword">val</span> replace : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>old:<a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>by:<a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>replace t ~old ~by</code> syntactically replaces all occurrences of <code>old</code> in <code>t</code> by the term <code>by</code>.</p></dd></dl><dl><dt class="spec value" id="val-replace_m"><a href="#val-replace_m" class="anchor"></a><code><span class="keyword">val</span> replace_m : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#module-Map">Map</a>.t</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>replace t m</code> syntactically replaces all occurrences of bindings of the map in <code>t</code>, starting from the root</p></dd></dl></section><section><header><h3 id="high-level-operations"><a href="#high-level-operations" class="anchor"></a>High-level operations</h3></header><dl><dt class="spec value" id="val-symbols"><a href="#val-symbols" class="anchor"></a><code><span class="keyword">val</span> symbols : <span>?&#8288;init:<a href="../../Logtk__ID/index.html#module-Set">Logtk.ID.Set</a>.t</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../Logtk__ID/index.html#module-Set">Logtk.ID.Set</a>.t</code></dt><dd><p>Symbols of the term (keys of signature)</p></dd></dl><dl><dt class="spec value" id="val-contains_symbol"><a href="#val-contains_symbol" class="anchor"></a><code><span class="keyword">val</span> contains_symbol : <a href="../ID/index.html#type-t">ID.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Does the term contain this given ID.t?</p></dd></dl></section><section><header><h3 id="fold"><a href="#fold" class="anchor"></a>Fold</h3></header><aside><p>High level fold-like combinators</p></aside><dl><dt class="spec value" id="val-all_positions"><a href="#val-all_positions" class="anchor"></a><code><span class="keyword">val</span> all_positions : <span>?&#8288;vars:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ty_args:bool</span> <span>&#45;&gt;</span> <span>?&#8288;var_args:bool</span> <span>&#45;&gt;</span> <span>?&#8288;fun_bodies:bool</span> <span>&#45;&gt;</span> <span>?&#8288;pos:<a href="../Position/index.html#type-t">Position.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span><a href="index.html#type-t">t</a> <a href="../Position/With/index.html#type-t">Position.With.t</a></span> Iter.t</span></code></dt><dd><p>Iterate on all sub-terms with their position.</p><dl><dt>parameter vars</dt><dd><p>specifies whether variables are folded on (default false).</p></dd></dl><dl><dt>parameter ty_args</dt><dd><p>specifies whether type arguments are folded on (default true).</p></dd></dl><dl><dt>parameter var_args</dt><dd><p>specifies whether arguments of applied variables are folded on (default true).</p></dd></dl><dl><dt>parameter fun_bodies</dt><dd><p>specifies whether bodies of lambda-expressions are folded on (default true).</p></dd></dl><dl><dt>parameter pos</dt><dd><p>the initial position (default empty)</p></dd></dl></dd></dl></section><section><header><h3 id="some-ac-utils"><a href="#some-ac-utils" class="anchor"></a>Some AC-utils</h3></header><div class="spec module-type" id="module-type-AC_SPEC"><a href="#module-type-AC_SPEC" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-AC_SPEC/index.html">AC_SPEC</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-AC"><a href="#module-AC" class="anchor"></a><code><span class="keyword">module</span> <a href="AC/index.html">AC</a> : <span class="keyword">functor</span> (<a href="AC/argument-1-A/index.html">A</a> : <a href="index.html#module-type-AC_SPEC">AC_SPEC</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h3 id="printing/parsing"><a href="#printing/parsing" class="anchor"></a>Printing/parsing</h3></header><dl><dt class="spec value" id="val-print_all_types"><a href="#val-print_all_types" class="anchor"></a><code><span class="keyword">val</span> print_all_types : <span>bool Pervasives.ref</span></code></dt><dd><p>If true, <a href="index.html#val-pp"><code>pp</code></a> will print the types of all annotated terms</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Interfaces/index.html#module-type-PRINT">Interfaces.PRINT</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../Interfaces/module-type-PRINT/index.html#type-t">t</a> := <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <span><a href="index.html#type-t">t</a> CCFormat.printer</span></code></dt><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Interfaces/index.html#module-type-PRINT_DE_BRUIJN">Interfaces.PRINT_DE_BRUIJN</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../Interfaces/module-type-PRINT_DE_BRUIJN/index.html#type-t">t</a> := <a href="index.html#type-t">t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../Interfaces/module-type-PRINT_DE_BRUIJN/index.html#type-term">term</a> := <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dt class="spec type" id="type-term"><a href="#type-term" class="anchor"></a><code><span class="keyword">type</span> term</code></dt><dt class="spec type" id="type-print_hook"><a href="#type-print_hook" class="anchor"></a><code><span class="keyword">type</span> print_hook</code><code> = int <span>&#45;&gt;</span> <span><a href="index.html#type-term">term</a> CCFormat.printer</span> <span>&#45;&gt;</span> Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>User-provided hook that can be used to print terms (for composite cases) before the default printing occurs. The int argument is the De Bruijn depth in the term. A hook takes as arguments the depth and the recursive printing function that it can use to print subterms. A hook should return <code>true</code> if it fired, <code>false</code> to fall back on the default printing.</p></dd></dl><dl><dt class="spec value" id="val-pp_depth"><a href="#val-pp_depth" class="anchor"></a><code><span class="keyword">val</span> pp_depth : <span>?&#8288;hooks:<span><a href="index.html#type-print_hook">print_hook</a> list</span></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> CCFormat.printer</span></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-pp_var"><a href="#val-pp_var" class="anchor"></a><code><span class="keyword">val</span> pp_var : <span><span><a href="../Type/index.html#type-t">Type.t</a> <a href="../HVar/index.html#type-t">HVar.t</a></span> CCFormat.printer</span></code></dt><dt class="spec value" id="val-add_hook"><a href="#val-add_hook" class="anchor"></a><code><span class="keyword">val</span> add_hook : <a href="index.html#type-print_hook">print_hook</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Hook used by default for printing</p></dd></dl><dl><dt class="spec value" id="val-default_hooks"><a href="#val-default_hooks" class="anchor"></a><code><span class="keyword">val</span> default_hooks : unit <span>&#45;&gt;</span> <span><a href="index.html#type-print_hook">print_hook</a> list</span></code></dt><dd><p>List of default hooks</p></dd></dl><dl><dt class="spec value" id="val-debugf"><a href="#val-debugf" class="anchor"></a><code><span class="keyword">val</span> debugf : Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>debugf printing, with sorts</p></dd></dl></section><section><header><h3 id="formulas"><a href="#formulas" class="anchor"></a>Formulas</h3></header><div class="spec module" id="module-Form"><a href="#module-Form" class="anchor"></a><code><span class="keyword">module</span> <a href="Form/index.html">Form</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h3 id="arith"><a href="#arith" class="anchor"></a>Arith</h3></header><div class="spec module" id="module-Arith"><a href="#module-Arith" class="anchor"></a><code><span class="keyword">module</span> <a href="Arith/index.html">Arith</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-close_quantifier"><a href="#val-close_quantifier" class="anchor"></a><code><span class="keyword">val</span> close_quantifier : <a href="../Builtin/index.html#type-t">Builtin.t</a> <span>&#45;&gt;</span> <span><a href="../Type/index.html#type-t">Type.t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-has_ho_subterm"><a href="#val-has_ho_subterm" class="anchor"></a><code><span class="keyword">val</span> has_ho_subterm : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt></dl><dl><dt class="spec module" id="module-DB"><a href="#module-DB" class="anchor"></a><code><span class="keyword">module</span> <a href="DB/index.html">DB</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl></section><section><header><h3 id="tptp"><a href="#tptp" class="anchor"></a>TPTP</h3></header><div class="spec module" id="module-TPTP"><a href="#module-TPTP" class="anchor"></a><code><span class="keyword">module</span> <a href="TPTP/index.html">TPTP</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-ZF"><a href="#module-ZF" class="anchor"></a><code><span class="keyword">module</span> <a href="ZF/index.html">ZF</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-pp_in"><a href="#val-pp_in" class="anchor"></a><code><span class="keyword">val</span> pp_in : <a href="../Output_format/index.html#type-t">Output_format.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> CCFormat.printer</span></code></dt></dl><div class="spec module" id="module-Conv"><a href="#module-Conv" class="anchor"></a><code><span class="keyword">module</span> <a href="Conv/index.html">Conv</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></section></div></body></html>