<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Int (logtk.Logtk__Monome.Int)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">logtk</a> &#x00BB; <a href="../index.html">Logtk__Monome</a> &#x00BB; Int</nav><h1>Module <code>Logtk__Monome.Int</code></h1><nav class="toc"><ul><li><a href="#modular-computations">Modular Computations</a></li><li><a href="#find-solutions">Find Solutions</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <span>Z.t <a href="../index.html#type-monome">monome</a></span></code></dt></dl><dl><dt class="spec value" id="val-const"><a href="#val-const" class="anchor"></a><code><span class="keyword">val</span> const : Z.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Empty monomial, from constant (decides type)</p></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">val</span> singleton : Z.t <span>&#45;&gt;</span> <a href="../index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>One term.</p></dd></dl><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : Z.t <span>&#45;&gt;</span> <span><span>(Z.t * <a href="../index.html#type-term">term</a>)</span> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-of_term"><a href="#val-of_term" class="anchor"></a><code><span class="keyword">val</span> of_term : <a href="../index.html#type-term">term</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> option</span></code></dt><dt class="spec value" id="val-of_term_exn"><a href="#val-of_term_exn" class="anchor"></a><code><span class="keyword">val</span> of_term_exn : <a href="../index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>try to get a monome from a term.</p><dl><dt>raises NotLinear</dt><dd><p>if the term is not a proper monome.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_term"><a href="#val-to_term" class="anchor"></a><code><span class="keyword">val</span> to_term : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-term">term</a></code></dt><dd><p>convert back to a term</p></dd></dl><dl><dt class="spec value" id="val-has_instances"><a href="#val-has_instances" class="anchor"></a><code><span class="keyword">val</span> has_instances : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>For real or rational, always true. For integers, returns true iff g divides <code>m.constant</code>, where g is the GCD of <code>c</code> for <code>c</code> in <code>m.coeffs</code>.</p><p>The intuition is that this returns <code>true</code> iff the monome actually has some instances in its type. Trivially true in reals or rationals, this is only the case for integers if <code>m.coeffs + m.constant = 0</code> is a satisfiable diophantine equation.</p></dd></dl><dl><dt class="spec value" id="val-quotient"><a href="#val-quotient" class="anchor"></a><code><span class="keyword">val</span> quotient : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> option</span></code></dt><dd><p><code>quotient e c</code> tries to divide <code>e</code> by <code>c</code>, returning <code>e/c</code> if it is still an integer expression. For instance, <code>quotient (2x + 4y) 2</code> will return <code>Some (x + 2y)</code></p></dd></dl><dl><dt class="spec value" id="val-divisible"><a href="#val-divisible" class="anchor"></a><code><span class="keyword">val</span> divisible : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> bool</code></dt><dd><p><code>divisible e n</code> returns true if all coefficients of <code>e</code> are divisible by <code>n</code> and n is an int &gt;= 2</p></dd></dl><dl><dt class="spec value" id="val-factorize"><a href="#val-factorize" class="anchor"></a><code><span class="keyword">val</span> factorize : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-t">t</a> * Z.t)</span> option</span></code></dt><dd><p>Factorize <code>e</code> into <code>Some (e',s)</code> if <code>e = e' x s</code>, None otherwise (ie if s=1). In case it returns <code>Some (e', s)</code>, <code>s &gt; 1</code> holds</p></dd></dl><dl><dt class="spec value" id="val-normalize_wrt_zero"><a href="#val-normalize_wrt_zero" class="anchor"></a><code><span class="keyword">val</span> normalize_wrt_zero : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Allows to multiply or divide by any positive number since we consider that the monome is equal to (or compared with) zero. For integer monomes, the result will have co-prime coefficients.</p></dd></dl><dl><dt class="spec value" id="val-reduce_same_factor"><a href="#val-reduce_same_factor" class="anchor"></a><code><span class="keyword">val</span> reduce_same_factor : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a></code></dt><dd><p><code>reduce_same_factor m1 m2 t</code> multiplies <code>m1</code> and <code>m2</code> by some constants, so that their coefficient for <code>t</code> is the same.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>t</code> does not belong to <code>m1</code> or <code>m2</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <span>(<a href="../index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="../index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="../../Logtk/Comparison/index.html#type-t">Logtk.Comparison.t</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../Logtk/Comparison/index.html#type-t">Logtk.Comparison.t</a></code></dt><dd><p>Compare monomes as if they were multisets of terms, the coefficient in front of a term being its multiplicity.</p></dd></dl><dl><dt class="spec value" id="val-to_multiset"><a href="#val-to_multiset" class="anchor"></a><code><span class="keyword">val</span> to_multiset : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../Logtk/Multisets/MT/index.html#type-t">Logtk.Multisets.MT.t</a></code></dt><dd><p>Multiset of terms with multiplicity</p></dd></dl><section><header><h3 id="modular-computations"><a href="#modular-computations" class="anchor"></a>Modular Computations</h3></header><div class="spec module" id="module-Modulo"><a href="#module-Modulo" class="anchor"></a><code><span class="keyword">module</span> <a href="Modulo/index.html">Modulo</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h3 id="find-solutions"><a href="#find-solutions" class="anchor"></a>Find Solutions</h3></header><div class="spec module" id="module-Solve"><a href="#module-Solve" class="anchor"></a><code><span class="keyword">module</span> <a href="Solve/index.html">Solve</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>