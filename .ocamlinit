#use "topfind";;
#require "unix";;
#require "zarith";;
#require "containers";;
#require "containers.data";;
#require "sequence";;
#require "gen";;
#require "oclock";;
#directory "_build/src/"
#directory "_build/src/core";;
#directory "_build/src/prover";;
#directory "_build/src/parsers";;
#directory "_build/src/meta/";;
#directory "_build/src/arbitrary/";;
#directory "_build/tests/";;

print_endline "load base lib....";;
#load "logtk.cma";;
open Logtk;;
module ST = InnerTerm;;
module T = Term;;
module PT = STerm;;
let (~<) = ID.make;;
#install_printer ID.pp;;
#install_printer Type.pp;;
#install_printer T.pp;;
#install_printer STerm.pp;;
#install_printer TypedSTerm.pp;;
#install_printer UntypedAST.pp_statement;;
#install_printer HVar.pp;;
#install_printer Subst.pp;;
#install_printer Signature.pp;;
#install_printer ParseLocation.pp;;
#install_printer Precedence.pp;;
#install_printer Precedence.Weight.pp;;
#install_printer Ordering.pp;;
#install_printer Position.pp;;
#install_printer Ordinal.pp;;

(* optional part: parser *)
print_endline "load parser lib...";;
#require "tip_parser";;
#load "logtk_parsers.cma";;
open Logtk_parsers;;

let psterm, pstmt, pstmt_l =
    let tyctx = TypeInference.Ctx.create () in
    let pt s =
      let t = Parse_zf.parse_term Lex_zf.token (Lexing.from_string s) in
      let t = TypeInference.infer_exn tyctx t in
      TypeInference.Ctx.exit_scope tyctx;
      t
    and pst s =
      let t = Parse_zf.parse_statement Lex_zf.token (Lexing.from_string s) in
      let t = TypeInference.infer_statement_exn tyctx t in
      TypeInference.Ctx.exit_scope tyctx;
      t
    and pst_l s =
      let l = Parse_zf.parse_statement_list Lex_zf.token (Lexing.from_string s) in
      let l = TypeInference.infer_statements_exn ~on_var:`Default ~ctx:tyctx (Sequence.of_list l) in
      TypeInference.Ctx.exit_scope tyctx;
      CCVector.to_list l
    in
    pt, pst, pst_l
;;

(* prelude *)
ignore (pstmt_l
  "val term : type.
   val a : term.
   val b : term.
   val c : term.
   val d : term.
   val e : term.
   val f : term -> term -> term.
   val g : term -> term.
   val h : term -> term.
   val ite : term -> term -> term -> term.
   val p : term -> term -> prop.
   val q : term -> prop.
   val r : term -> prop.
   val s : prop.
   val f_ho2: (term -> term ) -> (term -> term) -> term.
   val p_ho2: (term -> term ) -> (term -> term) -> prop.
   ");;

(* parse Term.t *)
let pterm =
  let ctx = T.Conv.create() in
  fun s ->
    psterm s |> T.Conv.of_simple_term_exn ctx
;;

(* optional part: arbitrary *)
#require "qcheck";;
#load "logtk_arbitrary.cma";;

print_endline "load prover lib...";;
#load "libzipperposition_prover.cma";;
module M = Monome;;
module MF = Monome.Focus;;
#install_printer FOTerm.pp;;
#install_printer Literal.pp;;
#install_printer Clause.pp;;
#install_printer STerm.pp;;
#install_printer Substs.FO.pp;;
#install_printer Proof.pp;;
#install_printer Signature.pp;;
#install_printer Type.pp;;
#install_printer Monome.pp;;
let pterm_tptp s = Parse_tptp.parse_term Lex_tptp.token (Lexing.from_string s);;
let pform_tptp s = Parse_tptp.parse_formula Lex_tptp.token (Lexing.from_string s);;
Printf.printf "finished loading\n";;
