<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>TypeInference (logtk.Logtk.TypeInference)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">logtk</a> &#x00BB; <a href="../index.html">Logtk</a> &#x00BB; TypeInference</nav><h1>Module <code>Logtk.TypeInference</code></h1><nav class="toc"><ul><li><a href="#type-inference">Type Inference</a><ul><li><a href="#types-for-builtins">Types for Builtins</a></li><li><a href="#typing-context">Typing context</a></li><li><a href="#hindley-milner-type-inference">Hindley-Milner Type Inference</a><ul><li><a href="#constraining-types">Constraining types</a></li></ul></li><li><a href="#statements">Statements</a></li></ul></li></ul></nav></header><section><header><h2 id="type-inference"><a href="#type-inference" class="anchor"></a>Type Inference</h2><p>This module is used for two things that overlap:</p><ul><li>inferring the types of symbols that have not been declared (e.g. in &quot;fof&quot; or &quot;cnf&quot; TPTP statements) so as to enrich a <a href="../Signature/index.html"><code>Signature</code></a></li><li>converting <i>untyped</i> terms or formulas into <i>typed</i> formulas, by inferring the exact type of each subterm (and possibly inferring type parameters).</li></ul><p>In this context, <b>generalizing</b> type variables means that if some ID.t whose type was unknown and its type still contains variables after the type inference, those variables are quantified instead of being bound to a default type (typically <span class="xref-unresolved" title="unresolved reference to &quot;Type.i&quot;"><a href="../index.html#module-Type"><code>Type</code></a>.i</span>).</p><p>For instance: say <code>f</code> is not declared and occurs in the term <code>f(f(nil))</code> with the declared constructor <code>nil : list(A)</code>. The inferred type for <code>f</code> should be something like <code>list(B) -&gt; list(B)</code>.</p><ul><li>If we generalize, we declare that <code>f : list(A) -&gt; list(A)</code> (for all <code>A</code>).</li><li>If we don't, we declare that <code>f : list($i) -&gt; list($i)</code>.</li></ul><p>Here we use a single scope when we unify and substitute type variables, the scope 0.</p><p>Many functions will use an Error monad to make errors explicit. The error type is <a href="index.html#type-or_error"><code>or_error</code></a>. The module <code>CCError</code> in containers can be used to deal with errors (including monadic operators).</p></header><dl><dt class="spec type" id="type-or_error"><a href="#type-or_error" class="anchor"></a><code><span class="keyword">type</span> <span>'a or_error</span></code><code> = <span><span>(<span class="type-var">'a</span>, string)</span> CCResult.t</span></code></dt><dt class="spec type" id="type-type_"><a href="#type-type_" class="anchor"></a><code><span class="keyword">type</span> type_</code><code> = <a href="../TypedSTerm/index.html#type-t">TypedSTerm.t</a></code></dt><dt class="spec type" id="type-untyped"><a href="#type-untyped" class="anchor"></a><code><span class="keyword">type</span> untyped</code><code> = <a href="../STerm/index.html#type-t">STerm.t</a></code></dt><dd><p>untyped term</p></dd></dl><dl><dt class="spec type" id="type-typed"><a href="#type-typed" class="anchor"></a><code><span class="keyword">type</span> typed</code><code> = <a href="../TypedSTerm/index.html#type-t">TypedSTerm.t</a></code></dt><dd><p>typed term</p></dd></dl><dl><dt class="spec type" id="type-loc"><a href="#type-loc" class="anchor"></a><code><span class="keyword">type</span> loc</code><code> = <a href="../ParseLocation/index.html#type-t">ParseLocation.t</a></code></dt></dl><dl><dt class="spec exception" id="exception-Error"><a href="#exception-Error" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Error</span> <span class="keyword">of</span> string</code></dt></dl><dl><dt class="spec value" id="val-section"><a href="#val-section" class="anchor"></a><code><span class="keyword">val</span> section : <a href="../Util/Section/index.html#type-t">Util.Section.t</a></code></dt></dl><section><header><h3 id="types-for-builtins"><a href="#types-for-builtins" class="anchor"></a>Types for Builtins</h3></header><div class="spec module" id="module-TyBuiltin"><a href="#module-TyBuiltin" class="anchor"></a><code><span class="keyword">module</span> <a href="TyBuiltin/index.html">TyBuiltin</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h3 id="typing-context"><a href="#typing-context" class="anchor"></a>Typing context</h3><p>This module provides a typing context, with an applicative interface. The context is used to map terms to types locally during type inference. It also keeps and updates a signature when symbols' types are inferred.</p><p>This module is quite low-level, and shouldn't be used in simple cases (see the following modules)</p></header><div class="spec module" id="module-Ctx"><a href="#module-Ctx" class="anchor"></a><code><span class="keyword">module</span> <a href="Ctx/index.html">Ctx</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-unify"><a href="#val-unify" class="anchor"></a><code><span class="keyword">val</span> unify : <span>?&#8288;loc:<a href="index.html#type-loc">loc</a></span> <span>&#45;&gt;</span> <a href="index.html#type-type_">type_</a> <span>&#45;&gt;</span> <a href="index.html#type-type_">type_</a> <span>&#45;&gt;</span> unit</code></dt></dl></section><section><header><h3 id="hindley-milner-type-inference"><a href="#hindley-milner-type-inference" class="anchor"></a>Hindley-Milner Type Inference</h3><p>This module, abstract in the exact kind of term it types, takes as input a signature and an <b>untyped term</b>, and updates the typing context so that the <b>untyped term</b> can be converted into a <b>typed term</b>.</p></header><dl><dt class="spec value" id="val-infer_ty_exn"><a href="#val-infer_ty_exn" class="anchor"></a><code><span class="keyword">val</span> infer_ty_exn : <a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> <a href="index.html#type-untyped">untyped</a> <span>&#45;&gt;</span> <a href="index.html#type-type_">type_</a></code></dt><dd><p>Type conversion from <a href="index.html#type-untyped"><code>untyped</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-infer_ty"><a href="#val-infer_ty" class="anchor"></a><code><span class="keyword">val</span> infer_ty : <a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> <a href="index.html#type-untyped">untyped</a> <span>&#45;&gt;</span> <span><a href="index.html#type-type_">type_</a> <a href="index.html#type-or_error">or_error</a></span></code></dt><dd><p>Type conversion from <a href="index.html#type-untyped"><code>untyped</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-infer_exn"><a href="#val-infer_exn" class="anchor"></a><code><span class="keyword">val</span> infer_exn : <a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> <a href="index.html#type-untyped">untyped</a> <span>&#45;&gt;</span> <a href="index.html#type-typed">typed</a></code></dt><dd><p>Infer the type of this term under the given signature. This updates the context's typing environment!</p><dl><dt>parameter ctx</dt><dd><p>the context</p></dd></dl><dl><dt>parameter untyped</dt><dd><p>the untyped term whose type must be inferred</p></dd></dl><dl><dt>raises Error</dt><dd><p>if the types are inconsistent</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-infer"><a href="#val-infer" class="anchor"></a><code><span class="keyword">val</span> infer : <a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> <a href="index.html#type-untyped">untyped</a> <span>&#45;&gt;</span> <span><a href="index.html#type-typed">typed</a> <a href="index.html#type-or_error">or_error</a></span></code></dt><dd><p>Safe version of <a href="index.html#val-infer_exn"><code>infer_exn</code></a>. It returns <code>`Error s</code> rather than raising <a href="index.html#exception-Error"><code>Error</code></a> if the typechecking fails.</p></dd></dl><dl><dt class="spec value" id="val-infer_prop_exn"><a href="#val-infer_prop_exn" class="anchor"></a><code><span class="keyword">val</span> infer_prop_exn : <a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> <a href="index.html#type-untyped">untyped</a> <span>&#45;&gt;</span> <a href="index.html#type-typed">typed</a></code></dt><dd><p>Same as <a href="index.html#val-infer_exn"><code>infer_exn</code></a> but forces the type of its result to be <a href="../TypedSTerm/index.html#val-prop"><code>TypedSTerm.prop</code></a></p></dd></dl><dl><dt class="spec value" id="val-infer_clause_exn"><a href="#val-infer_clause_exn" class="anchor"></a><code><span class="keyword">val</span> infer_clause_exn : <a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-untyped">untyped</a> list</span> <span>&#45;&gt;</span> <span><a href="index.html#type-typed">typed</a> list</span></code></dt><dd><p>Convert a clause. Free variables in each of the list's elements are shared</p></dd></dl><section><header><h4 id="constraining-types"><a href="#constraining-types" class="anchor"></a>Constraining types</h4><p>This section is mostly useful for inferring a signature without converting untyped_terms into typed_terms.</p></header><dl><dt class="spec value" id="val-constrain_term_term_exn"><a href="#val-constrain_term_term_exn" class="anchor"></a><code><span class="keyword">val</span> constrain_term_term_exn : <span>?&#8288;loc:<a href="index.html#type-loc">loc</a></span> <span>&#45;&gt;</span> <a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> <a href="index.html#type-untyped">untyped</a> <span>&#45;&gt;</span> <a href="index.html#type-untyped">untyped</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Force the two terms to have the same type in this context</p><dl><dt>raises Error</dt><dd><p>if an inconsistency is detected</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-constrain_term_type_exn"><a href="#val-constrain_term_type_exn" class="anchor"></a><code><span class="keyword">val</span> constrain_term_type_exn : <span>?&#8288;loc:<a href="index.html#type-loc">loc</a></span> <span>&#45;&gt;</span> <a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> <a href="index.html#type-untyped">untyped</a> <span>&#45;&gt;</span> <a href="index.html#type-type_">type_</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Force the term's type and the given type to be the same.</p><dl><dt>raises Error</dt><dd><p>if an inconsistency is detected</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-constrain_term_term"><a href="#val-constrain_term_term" class="anchor"></a><code><span class="keyword">val</span> constrain_term_term : <span>?&#8288;loc:<a href="index.html#type-loc">loc</a></span> <span>&#45;&gt;</span> <a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> <a href="index.html#type-untyped">untyped</a> <span>&#45;&gt;</span> <a href="index.html#type-untyped">untyped</a> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-or_error">or_error</a></span></code></dt><dd><p>Safe version of <a href="index.html#val-constrain_term_term_exn"><code>constrain_term_term_exn</code></a></p></dd></dl><dl><dt class="spec value" id="val-constrain_term_type"><a href="#val-constrain_term_type" class="anchor"></a><code><span class="keyword">val</span> constrain_term_type : <span>?&#8288;loc:<a href="index.html#type-loc">loc</a></span> <span>&#45;&gt;</span> <a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> <a href="index.html#type-untyped">untyped</a> <span>&#45;&gt;</span> <a href="index.html#type-type_">type_</a> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-or_error">or_error</a></span></code></dt><dd><p>Safe version of <a href="index.html#val-constrain_term_type_exn"><code>constrain_term_type_exn</code></a></p></dd></dl></section></section><section><header><h3 id="statements"><a href="#statements" class="anchor"></a>Statements</h3></header><dl><dt class="spec type" id="type-typed_statement"><a href="#type-typed_statement" class="anchor"></a><code><span class="keyword">type</span> typed_statement</code><code> = <span><span>(<a href="index.html#type-typed">typed</a>, <a href="index.html#type-typed">typed</a>, <a href="index.html#type-type_">type_</a>)</span> <a href="../Statement/index.html#type-t">Statement.t</a></span></code></dt></dl><dl><dt class="spec value" id="val-infer_statement_exn"><a href="#val-infer_statement_exn" class="anchor"></a><code><span class="keyword">val</span> infer_statement_exn : <span>?&#8288;file:string</span> <span>&#45;&gt;</span> <a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> <a href="../UntypedAST/index.html#type-statement">UntypedAST.statement</a> <span>&#45;&gt;</span> <a href="index.html#type-typed_statement">typed_statement</a> * <span><a href="index.html#type-typed_statement">typed_statement</a> list</span></code></dt><dd><p><code>infer_statement ctx ~f st</code> checks and convert <code>st</code> into a typed statements, and a list of auxiliary type declarations for symbols that were inferred implicitly.</p></dd></dl><dl><dt class="spec value" id="val-infer_statements_exn"><a href="#val-infer_statements_exn" class="anchor"></a><code><span class="keyword">val</span> infer_statements_exn : <span>?&#8288;def_as_rewrite:bool</span> <span>&#45;&gt;</span> <span>?&#8288;on_var:<span>[ `Infer <span>| `Default</span> ]</span></span> <span>&#45;&gt;</span> <span>?&#8288;on_undef:<span>[ `Warn <span>| `Fail</span> <span>| `Guess</span> ]</span></span> <span>&#45;&gt;</span> <span>?&#8288;on_shadow:<span>[ `Warn <span>| `Ignore</span> ]</span></span> <span>&#45;&gt;</span> <span>?&#8288;ctx:<a href="Ctx/index.html#type-t">Ctx.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;file:string</span> <span>&#45;&gt;</span> <span>implicit_ty_args:bool</span> <span>&#45;&gt;</span> <span><a href="../UntypedAST/index.html#type-statement">UntypedAST.statement</a> Iter.t</span> <span>&#45;&gt;</span> <span><a href="index.html#type-typed_statement">typed_statement</a> CCVector.ro_vector</span></code></dt><dd><p>Infer all statements</p><dl><dt>parameter def_as_rewrite</dt><dd><p>if true, definitions becomes rewrite rules</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-infer_statements"><a href="#val-infer_statements" class="anchor"></a><code><span class="keyword">val</span> infer_statements : <span>?&#8288;def_as_rewrite:bool</span> <span>&#45;&gt;</span> <span>?&#8288;on_var:<span>[ `Infer <span>| `Default</span> ]</span></span> <span>&#45;&gt;</span> <span>?&#8288;on_undef:<span>[ `Warn <span>| `Fail</span> <span>| `Guess</span> ]</span></span> <span>&#45;&gt;</span> <span>?&#8288;on_shadow:<span>[ `Warn <span>| `Ignore</span> ]</span></span> <span>&#45;&gt;</span> <span>?&#8288;ctx:<a href="Ctx/index.html#type-t">Ctx.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;file:string</span> <span>&#45;&gt;</span> <span>implicit_ty_args:bool</span> <span>&#45;&gt;</span> <span><a href="../UntypedAST/index.html#type-statement">UntypedAST.statement</a> Iter.t</span> <span>&#45;&gt;</span> <span><span><a href="index.html#type-typed_statement">typed_statement</a> CCVector.ro_vector</span> <a href="index.html#type-or_error">or_error</a></span></code></dt></dl></section></section></div></body></html>