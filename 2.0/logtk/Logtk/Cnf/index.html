<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Cnf (logtk.Logtk.Cnf)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">logtk</a> &#x00BB; <a href="../index.html">Logtk</a> &#x00BB; Cnf</nav><h1>Module <code>Logtk.Cnf</code></h1><nav class="toc"><ul><li><a href="#reduction-to-cnf-and-simplifications">Reduction to CNF and Simplifications</a><ul><li><a href="#main-interface">Main Interface</a></li><li><a href="#conversions">Conversions</a></li></ul></li></ul></nav></header><section><header><h2 id="reduction-to-cnf-and-simplifications"><a href="#reduction-to-cnf-and-simplifications" class="anchor"></a>Reduction to CNF and Simplifications</h2></header><aside><p><code>CNF</code> allows to transition from a free-form AST (with statements containing formulas as <a href="../TypedSTerm/index.html#type-t"><code>TypedSTerm.t</code></a>) into an AST using clauses and without some constructs such as &quot;if/then/else&quot; or &quot;match&quot; or &quot;let&quot;. The output is more suitable for a Superposition-like prover.</p><p>There also are conversion functions to go from clauses that use <a href="../TypedSTerm/index.html#type-t"><code>TypedSTerm.t</code></a>, into clauses that use the <a href="../Term/index.html#type-t"><code>Term.t</code></a> (hashconsed, and usable in unification, indexing, etc.).</p><p>We follow chapter 6 &quot;Computing small clause normal forms&quot; of the &quot;handbook of automated reasoning&quot; for the theoretical part.</p><p>A few notes:</p><p>In worst case, normal CNF transformation can lead to an exponential number of clauses, which is prohibitive. To avoid that, we use the Tseitin trick to <b>name</b> some intermediate formulas by introducing fresh symbols (herein named &quot;proxies&quot;) and defining them to be equivalent to the formula they define.</p><p>This is done only if we estimate that adding the proxy will reduce the final number of clauses (See <code>Estimation</code> module).</p><p>Before doing CNF we remove all the high-level constructs such as pattern-matching and &quot;let&quot; by introducing new symbols and defining the subterm to eliminate using this new symbol (See <code>Flatten</code> module). It is important to capture variables properly in this phase (as in closure conversion).</p></aside><dl><dt class="spec type" id="type-term"><a href="#type-term" class="anchor"></a><code><span class="keyword">type</span> term</code><code> = <a href="../TypedSTerm/index.html#type-t">TypedSTerm.t</a></code></dt><dt class="spec type" id="type-form"><a href="#type-form" class="anchor"></a><code><span class="keyword">type</span> form</code><code> = <a href="../TypedSTerm/index.html#type-t">TypedSTerm.t</a></code></dt><dt class="spec type" id="type-type_"><a href="#type-type_" class="anchor"></a><code><span class="keyword">type</span> type_</code><code> = <a href="../TypedSTerm/index.html#type-t">TypedSTerm.t</a></code></dt><dt class="spec type" id="type-lit"><a href="#type-lit" class="anchor"></a><code><span class="keyword">type</span> lit</code><code> = <span><a href="index.html#type-term">term</a> <a href="../SLiteral/index.html#type-t">SLiteral.t</a></span></code></dt></dl><aside><p>See &quot;computing small normal forms&quot;, in the handbook of automated reasoning. All transformations are made on curried terms and formulas.</p></aside><dl><dt class="spec exception" id="exception-Error"><a href="#exception-Error" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Error</span> <span class="keyword">of</span> string</code></dt><dt class="spec exception" id="exception-NotCNF"><a href="#exception-NotCNF" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">NotCNF</span> <span class="keyword">of</span> <a href="index.html#type-form">form</a></code></dt></dl><dl><dt class="spec value" id="val-miniscope"><a href="#val-miniscope" class="anchor"></a><code><span class="keyword">val</span> miniscope : <span>?&#8288;distribute_exists:bool</span> <span>&#45;&gt;</span> <a href="index.html#type-form">form</a> <span>&#45;&gt;</span> <a href="index.html#type-form">form</a></code></dt><dd><p>Apply miniscoping transformation to the term.</p><dl><dt>parameter distribute_exists</dt><dd><p>see whether ?X:(p(X)|q(X)) should be transformed into (?X: p(X) | ?X: q(X)). Default: <code>false</code></p></dd></dl></dd></dl><dl><dt class="spec type" id="type-options"><a href="#type-options" class="anchor"></a><code><span class="keyword">type</span> options</code><code> = </code><table class="variant"><tr id="type-options.LazyCnf" class="anchored"><td class="def constructor"><a href="#type-options.LazyCnf" class="anchor"></a><code>| </code><code><span class="constructor">LazyCnf</span></code></td><td class="doc"><p>if enabled, inital formulas will not be converted to the clausal form. Instead, formulas will be presented as is, and lazy calculus rules will be used to clausify.</p></td></tr><tr id="type-options.DistributeExists" class="anchored"><td class="def constructor"><a href="#type-options.DistributeExists" class="anchor"></a><code>| </code><code><span class="constructor">DistributeExists</span></code></td><td class="doc"><p>if enabled, will distribute existential quantifiers over disjunctions. This can make skolem symbols smaller (smaller arity) but introduce more of them.</p></td></tr><tr id="type-options.DisableRenaming" class="anchored"><td class="def constructor"><a href="#type-options.DisableRenaming" class="anchor"></a><code>| </code><code><span class="constructor">DisableRenaming</span></code></td><td class="doc"><p>disables formula renaming. Can re-introduce the worst-case exponential behavior of CNF.</p></td></tr><tr id="type-options.InitialProcessing" class="anchored"><td class="def constructor"><a href="#type-options.InitialProcessing" class="anchor"></a><code>| </code><code><span class="constructor">InitialProcessing</span> <span class="keyword">of</span> <a href="index.html#type-form">form</a> <span>&#45;&gt;</span> <a href="index.html#type-form">form</a></code></td><td class="doc"><p>any processing, at the beginning, before CNF starts</p></td></tr><tr id="type-options.PostNNF" class="anchored"><td class="def constructor"><a href="#type-options.PostNNF" class="anchor"></a><code>| </code><code><span class="constructor">PostNNF</span> <span class="keyword">of</span> <a href="index.html#type-form">form</a> <span>&#45;&gt;</span> <a href="index.html#type-form">form</a></code></td><td class="doc"><p>any processing that keeps negation at leaves, just after reduction to NNF. Its output must not break the NNF form (negation at root only).</p></td></tr><tr id="type-options.PostSkolem" class="anchored"><td class="def constructor"><a href="#type-options.PostSkolem" class="anchor"></a><code>| </code><code><span class="constructor">PostSkolem</span> <span class="keyword">of</span> <a href="index.html#type-form">form</a> <span>&#45;&gt;</span> <a href="index.html#type-form">form</a></code></td><td class="doc"><p>transformation applied just after skolemization. It must not break skolemization nor NNF (no quantifier, no non-leaf negation).</p></td></tr></table></dt><dd><p>Options are used to tune the behavior of the CNF conversion.</p></dd></dl><dl><dt class="spec type" id="type-clause"><a href="#type-clause" class="anchor"></a><code><span class="keyword">type</span> clause</code><code> = <span><a href="index.html#type-lit">lit</a> list</span></code></dt><dd><p>Basic clause representation, as list of literals</p></dd></dl><dl><dt class="spec value" id="val-clause_to_fo"><a href="#val-clause_to_fo" class="anchor"></a><code><span class="keyword">val</span> clause_to_fo : <span>?&#8288;ctx:<a href="../Term/Conv/index.html#type-ctx">Term.Conv.ctx</a></span> <span>&#45;&gt;</span> <a href="index.html#type-clause">clause</a> <span>&#45;&gt;</span> <span><span><a href="../Term/index.html#type-t">Term.t</a> <a href="../SLiteral/index.html#type-t">SLiteral.t</a></span> list</span></code></dt></dl><dl><dt class="spec type" id="type-f_statement"><a href="#type-f_statement" class="anchor"></a><code><span class="keyword">type</span> f_statement</code><code> = <span><span>(<a href="index.html#type-term">term</a>, <a href="index.html#type-term">term</a>, <a href="index.html#type-type_">type_</a>)</span> <a href="../Statement/index.html#type-t">Statement.t</a></span></code></dt><dd><p>A statement before CNF</p></dd></dl><dl><dt class="spec type" id="type-c_statement"><a href="#type-c_statement" class="anchor"></a><code><span class="keyword">type</span> c_statement</code><code> = <span><span>(<a href="index.html#type-clause">clause</a>, <a href="index.html#type-term">term</a>, <a href="index.html#type-type_">type_</a>)</span> <a href="../Statement/index.html#type-t">Statement.t</a></span></code></dt><dd><p>A statement after CNF</p></dd></dl><dl><dt class="spec value" id="val-pp_f_statement"><a href="#val-pp_f_statement" class="anchor"></a><code><span class="keyword">val</span> pp_f_statement : <span><a href="index.html#type-f_statement">f_statement</a> CCFormat.printer</span></code></dt><dt class="spec value" id="val-pp_c_statement"><a href="#val-pp_c_statement" class="anchor"></a><code><span class="keyword">val</span> pp_c_statement : <span><a href="index.html#type-c_statement">c_statement</a> CCFormat.printer</span></code></dt><dt class="spec value" id="val-pp_fo_c_statement"><a href="#val-pp_fo_c_statement" class="anchor"></a><code><span class="keyword">val</span> pp_fo_c_statement : <span><span><span>(<span><span><a href="../Term/index.html#type-t">Term.t</a> <a href="../SLiteral/index.html#type-t">SLiteral.t</a></span> list</span>, <a href="../Term/index.html#type-t">Term.t</a>, <a href="../Type/index.html#type-t">Type.t</a>)</span> <a href="../Statement/index.html#type-t">Statement.t</a></span> CCFormat.printer</span></code></dt><dt class="spec value" id="val-is_clause"><a href="#val-is_clause" class="anchor"></a><code><span class="keyword">val</span> is_clause : <a href="index.html#type-form">form</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_cnf"><a href="#val-is_cnf" class="anchor"></a><code><span class="keyword">val</span> is_cnf : <a href="index.html#type-form">form</a> <span>&#45;&gt;</span> bool</code></dt></dl><section><header><h3 id="main-interface"><a href="#main-interface" class="anchor"></a>Main Interface</h3></header><dl><dt class="spec value" id="val-cnf_of"><a href="#val-cnf_of" class="anchor"></a><code><span class="keyword">val</span> cnf_of : <span>ctx:<a href="../Skolem/index.html#type-ctx">Skolem.ctx</a></span> <span>&#45;&gt;</span> <span>?&#8288;opts:<span><a href="index.html#type-options">options</a> list</span></span> <span>&#45;&gt;</span> <a href="index.html#type-f_statement">f_statement</a> <span>&#45;&gt;</span> <span><a href="index.html#type-c_statement">c_statement</a> CCVector.ro_vector</span></code></dt><dd><p>Transform the statement into proper CNF; returns a list of statements, including type declarations for new Skolem symbols or formulas proxies. Options are used to tune the behavior.</p></dd></dl><dl><dt class="spec value" id="val-cnf_of_iter"><a href="#val-cnf_of_iter" class="anchor"></a><code><span class="keyword">val</span> cnf_of_iter : <span>ctx:<a href="../Skolem/index.html#type-ctx">Skolem.ctx</a></span> <span>&#45;&gt;</span> <span>?&#8288;opts:<span><a href="index.html#type-options">options</a> list</span></span> <span>&#45;&gt;</span> <span><a href="index.html#type-f_statement">f_statement</a> Iter.t</span> <span>&#45;&gt;</span> <span><a href="index.html#type-c_statement">c_statement</a> CCVector.ro_vector</span></code></dt><dt class="spec value" id="val-type_declarations"><a href="#val-type_declarations" class="anchor"></a><code><span class="keyword">val</span> type_declarations : <span><a href="index.html#type-c_statement">c_statement</a> Iter.t</span> <span>&#45;&gt;</span> <span><a href="index.html#type-type_">type_</a> <a href="../../Logtk__ID/index.html#module-Map">Logtk.ID.Map</a>.t</span></code></dt><dd><p>Compute the types declared in the statement sequence</p></dd></dl></section><section><header><h3 id="conversions"><a href="#conversions" class="anchor"></a>Conversions</h3></header><dl><dt class="spec value" id="val-convert"><a href="#val-convert" class="anchor"></a><code><span class="keyword">val</span> convert : <span><a href="index.html#type-c_statement">c_statement</a> Iter.t</span> <span>&#45;&gt;</span> <span><a href="../Statement/index.html#type-clause_t">Statement.clause_t</a> CCVector.ro_vector</span></code></dt><dd><p>Converts statements based on <a href="../TypedSTerm/index.html"><code>TypedSTerm</code></a> into statements based on <a href="../Term/index.html"><code>Term</code></a> and <a href="../Type/index.html"><code>Type</code></a></p></dd></dl></section></section></div></body></html>